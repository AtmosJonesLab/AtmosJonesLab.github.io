<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Atmos Jones Lab</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  
  
</head>
<body>
  <header>
    <h1>Atmos Jones Lab</h1>
    <nav>
      <a href="index.html">Home</a>
      <a href="projects.html">Projects</a>
      <a href="team.html">Team</a>
      <a href=" https://bsky.app/profile/treesrawesome.bsky.social" target="_blank" class="bsky-link">
        <img src="bluesky-circle-logo-icon-bluesky-app-editable-transparent-background-premium-social-media-design-for-digital-download-free-png.png" width="50" alt="Bluesky Logo" class="bsky-logo">
      </a>
    </nav>
  </header>
  <section class="hero">
    <h2>Urban Tree Ecophysiology Network</h2>
    <p>
     We are collecting data from a sugar maple (Acer saccharum) located on Georgetown's campus in Washington, D.C. 
     This tree is part of the Urban Trees Ecophysiology Network (UTEN), a network of researchers aiming to understand the 
     urban trees response to climate change.
     The data is collected using a variety of sensors.
    </p>

  </section>
    <h2 class="section-title">Map of Data Locations</h2>
  
    <div id="map"></div>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script>
      // Initialize the map
      var map = L.map('map').setView([38.90781, -77.07416], 16); 
    
      // Add OpenStreetMap tiles
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);
    
      // Add markers
      var locations = [
        { name: "Harbin Sugar Maple", coords: [38.90781, -77.07416] },
        { name: "Hoya Harvest Garden Weather Station", coords: [38.90940, -77.07490] },
       
      ];
    
      locations.forEach(function(loc) {
        L.marker(loc.coords).addTo(map)
          .bindPopup(loc.name)
          .openPopup();
      });
    </script>

<section class="carousel-section"> 
  <div class="carousel">
    <button class="carousel-btn prev">‹</button>

    <div class="carousel-track-container">
      <ul class="carousel-track">
        <li class="carousel-slide"><img src="treephotos/IMG_3620.jpeg" alt="Image 1"></li>
        <li class="carousel-slide"><img src="treephotos/IMG_3613.jpeg" alt="Image 2"></li>
        <li class="carousel-slide"><img src="treephotos/IMG_3615.jpeg" alt="Image 3"></li>
        <li class="carousel-slide"><img src="treephotos/IMG_3619.jpeg" alt="Image 4"></li>
        <li class="carousel-slide"><img src="treephotos/IMG_3610.jpeg" alt="Image 5"></li>
      </ul>
    </div>

    <button class="carousel-btn next">›</button>
  </div>
</section>

<section id="harbin-section">
  <h2 class="section-title">Data from Harbin Sugar Maple</h2>

  <!-- Temperature + Humidity -->
  <div class="graph-grid">
    <div class="chart-wrapper" onclick="toggleExpand(this)">
      <button class="close-btn" onclick="event.stopPropagation(); this.parentElement.classList.remove('expanded')">✕</button>
      <canvas id="combinedTempChart"></canvas>
    </div>

    <div class="chart-wrapper" onclick="toggleExpand(this)">
      <button class="close-btn" onclick="event.stopPropagation(); this.parentElement.classList.remove('expanded')">✕</button>
      <canvas id="combinedHumChart"></canvas>
    </div>
  </div>

  <!-- Dendrometer + LD -->
  <div class="graph-grid">
    <div class="chart-wrapper" onclick="toggleExpand(this)">
      <button class="close-btn" onclick="event.stopPropagation(); this.parentElement.classList.remove('expanded')">✕</button>
      <canvas id="pdendrochart"></canvas>
    </div>

    <div class="chart-wrapper" onclick="toggleExpand(this)">
      <button class="close-btn" onclick="event.stopPropagation(); this.parentElement.classList.remove('expanded')">✕</button>
      <canvas id="LDchart"></canvas>
    </div>
  </div>

  <!-- Battery charts -->
  <div class="graph-grid battery-charts-row">
    <div class="chart-wrapper" onclick="toggleExpand(this)">
      <button class="close-btn" onclick="event.stopPropagation(); this.parentElement.classList.remove('expanded')">✕</button>
      <canvas id="batteryChart"></canvas>
    </div>

    <div class="battery-percent-wrapper">
      <canvas id="batteryPercent" width="200" height="200"></canvas>
    </div>
  </div>
</section>

<script>
  // Expand/Collapse Chart Functionality
  function toggleExpand(wrapper) {
    document.querySelectorAll('.chart-wrapper.expanded').forEach(el => {
      if (el !== wrapper) el.classList.remove('expanded');
    });
    wrapper.classList.toggle('expanded');
  }

  // Close expanded charts when clicking outside
  document.addEventListener('click', e => {
    const expanded = document.querySelector('.chart-wrapper.expanded');
    if (expanded && !expanded.contains(e.target)) expanded.classList.remove('expanded');
  });
</script>

<!-- Weather Station Section -->
<section id="hhg-section">
  <h2 class="section-title">Hoya Harvest Weather Station</h2>

  <div class="graph-grid">
    <div class="chart-wrapper" onclick="toggleExpand(this)">
      <button class="close-btn" onclick="event.stopPropagation(); this.parentElement.classList.remove('expanded')">✕</button>
      <canvas id="weatherRainfall"></canvas>
    </div>

    <div class="chart-wrapper" onclick="toggleExpand(this)">
      <button class="close-btn" onclick="event.stopPropagation(); this.parentElement.classList.remove('expanded')">✕</button>
      <canvas id="weatherSolar"></canvas>
    </div>
  </div>

  <p class="footer" id="weatherFooter"></p>
</section>

<!-- Data Table Section -->
<h2 class="section-title">Raw Sensor Readings</h2>

<a href="https://atmosjoneslab.github.io/prettydata.json" download="prettydata.json">
  <button>Download Data</button>
</a>

<table border="1" id="sensor-table">
  <thead>
    <tr>
      <th>Timestamp</th>
      <th>Temperature</th>
      <th>Humidity</th>
      <th>Point Dendrometer</th>
      <th>LD</th>
      <th>Battery State</th>
      <th>Battery Voltage</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<!-- ================== Chart + Data Script ================== -->
<script>
    Chart.register({
  id: 'noDataPlugin',
  afterDraw(chart) {
    const datasets = chart.data.datasets || [];

    // Check if ANY dataset has at least one valid numeric value (0 counts as valid)
    const hasValidData = datasets.some(ds =>
      Array.isArray(ds.data) &&
      ds.data.some(point => point && point.y !== null && point.y !== undefined && !isNaN(point.y))
    );

    if (!hasValidData) {
      const { ctx, chartArea } = chart;
      const message = chart.config.options?.plugins?.noDataMessage || 'No valid data available';
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#9ca3af'; // Tailwind gray-400
      ctx.font = '16px sans-serif';
      ctx.fillText(message, (chartArea.left + chartArea.right) / 2, (chartArea.top + chartArea.bottom) / 2);
      ctx.restore();
    }
  }
});

function getAutoScaleBounds(data, lowerPercentile = 1, upperPercentile = 99) {
  if (!Array.isArray(data) || data.length === 0) return [null, null];
  const values = data
    .map(d => d.y)
    .filter(v => typeof v === 'number' && isFinite(v))
    .sort((a, b) => a - b);
  if (values.length < 3) return [Math.min(...values), Math.max(...values)];

  const low = values[Math.floor(values.length * lowerPercentile / 100)];
  const high = values[Math.floor(values.length * upperPercentile / 100)];
  return [low, high];
}


  const drawChart = (canvasId, label, datasets, { useGradient = false, spanGaps = true } = {}) => {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return console.warn(`Canvas not found: ${canvasId}`);

    const ctx = canvas.getContext('2d');
    const existing = Chart.getChart(canvas);
    if (existing) existing.destroy();

    const formattedDatasets = (Array.isArray(datasets) ? datasets : [datasets]).map(({ label, data, color }) => {
      let strokeStyle = color || '#3b82f6';
      if (useGradient) {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#ef4444');
        gradient.addColorStop(1, '#3b82f6');
        strokeStyle = gradient;
      }
      return {
        label,
        data,
        borderColor: strokeStyle,
        backgroundColor: strokeStyle,
        borderWidth: 2,
        fill: false,
        tension: 0.4,
        pointRadius: 2,
        pointBackgroundColor: strokeStyle,
        spanGaps
      };
    });

    // Calculate combined y-bounds for all datasets
    let yMin = null, yMax = null;
    (Array.isArray(datasets) ? datasets : [datasets]).forEach(ds => {
      const [low, high] = getAutoScaleBounds(ds.data);
      if (low !== null && high !== null) {
        yMin = yMin === null ? low : Math.min(yMin, low);
        yMax = yMax === null ? high : Math.max(yMax, high);
      }
    });

   
    new Chart(ctx, {
      type: 'line',
      data: { datasets: formattedDatasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            type: 'time',
            time: { unit: 'minute', displayFormats: { minute: 'MMM d, HH:mm' } },
            ticks: { maxRotation: 45, autoSkip: true, font: { size: 8 } },
            title: { display: true, text: 'Time', font: { size: 14 } }
          },
          y: {
            min: yMin,
            max: yMax,
            title: { display: true, text: label, font: { size: 14 } },
          }
        },
        plugins: {
          title: {
            display: true,
            text: label,
            font: { size: 20, weight: 'bold' },
            padding: { top: 10, bottom: 10 }
          },
          legend: { display: true, position: 'top' }
        }
      }
    });
  };


  const drawBatteryChart = (canvasId, latestVoltage, maxVoltage = 4.5) => {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const percent = Math.min(latestVoltage / maxVoltage, 1);
    const color = percent > 0.75 ? '#22c55e' : percent > 0.5 ? '#facc15' : '#ef4444';

    new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: ['Battery', 'Remaining'],
        datasets: [{ data: [percent * 100, 100 - percent * 100], backgroundColor: [color, '#e5e7eb'], borderWidth: 0 }]
      },
      options: {
        responsive: false,
        cutout: '70%',
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: context => `${context.label}: ${context.raw.toFixed(1)}%`
            }
          },
          title: {
            display: true,
            text: `Battery: ${latestVoltage.toFixed(2)}V`,
            font: { size: 18 }
          }
        }
      }
    });
  };

    
      // Load both local JSON and Google Sheets JSON
       Promise.all([
        fetch('./data.json').then(res => res.json()), 
        fetch("./weather_data.json").then(res => res.json()),
        // fetch("./sapData.json").then(res => res.json())
       ])
        .then(([localData, apiData]) => {
          
    

          const rows = localData.values;

          const sensorData = {
            "temperature": [],
            "humidity": [],
            "point dendrometer": [],
            "ld": [],
            "battery state": [],
            "battery voltage": []
          };
    
          rows.forEach(([type, epochtime, timestamp, value]) => {
            const key = type.toLowerCase();
            const time = new Date(parseInt(epochtime) * 1000);

            if (!sensorData[key]) return;

            if (key === "battery state") {
              sensorData[key].push({ x: time, y: value }); // keep as string
            } else {
              const numericValue = parseFloat(value);
              
              if (!isNaN(numericValue)) {
                sensorData[key].push({ x: time, y: numericValue });
              }
            }
          });
    
          for (const key in sensorData) {
            sensorData[key].sort((a, b) => a.x - b.x);
          }
          
        
          const recentData = {};
          for (const key in sensorData) {
            recentData[key] = sensorData[key].slice(-1000);
          }
          console.log(recentData);

          // --- Build local data table ---
          const tableBody = document.querySelector("#sensor-table tbody");
          const mergedData = {};

          // Merge all sensor data by rounded timestamp
          ["humidity", "temperature", "point dendrometer", "ld", "battery state", "battery voltage"].forEach(sensor => {
          sensorData[sensor].forEach(({ x, y }) => {
            if (!(x instanceof Date) || isNaN(x)) {
              // console.warn(`Skipping invalid timestamp for ${sensor}:`, x, y);
              return;
  }
            const timestamp = new Date(Math.round(x.getTime() / 60000) * 60000).toISOString();
            if (!mergedData[timestamp]) mergedData[timestamp] = {};
            mergedData[timestamp][sensor] = y;
          });
        });

          // Sort and populate table
          Object.keys(mergedData).sort().forEach(ts => {
            const row = mergedData[ts];
            const tr = document.createElement("tr");

            tr.innerHTML = `
              <td>${new Date(ts).toLocaleString()}</td>
              <td>${row["humidity"]?.toFixed(2) ?? "-"}</td>
              <td>${row["temperature"]?.toFixed(2) ?? "-"}</td>
              <td>${row["point dendrometer"]?.toFixed(2) ?? "-"}</td>
              <td>${row["ld"]?.toFixed(2) ?? "-"}</td>
              <td>${row["battery state"] ?? "-"}</td>
              <td>${row["battery voltage"]?.toFixed(2) ?? "-"}</td>
            `;
            tableBody.prepend(tr);
          });
    //--------------------build api weather dataset--------------------
          

         function cleanWeatherData(data, key, convert = v => v) {
          return data
            .filter(d => d && d[key] !== null && d[key] !== undefined && d[key] !== '' && !isNaN(Number(d[key])))
            .map(d => ({
              x: new Date(Number(d.ts) * 1000),
              y: convert(Number(d[key]))
            }));
        }

        const weatherTemp = cleanWeatherData(apiData, 'temp_out', v => (v - 32) * 5 / 9);
        const weatherHum = cleanWeatherData(apiData, 'hum_out');
        const weatherRainfall = cleanWeatherData(apiData, 'rainfall_mm');
        const weatherSolar = cleanWeatherData(apiData, 'solar_rad_avg');

        const recentWeatherTemp = weatherTemp[weatherTemp.length - 1000];
        const recentWeatherHum = weatherHum[weatherHum.length - 1000];
        const recentWeatherRainfall = weatherRainfall[weatherRainfall.length - 1000];
        const recentWeatherSolar = weatherSolar[weatherSolar.length - 1000];

//--------------------build sapflow dataset--------------------
      // const headers = sapData.values[0];
      // const dataRows = sapData.values.slice(1);

      // const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b']; // sapflow0–3
      // const timestampIndex = headers.indexOf("timestamp");
      // const pulseIndex = headers.indexOf("pulsenumber");
      // const sapflowIndices = ["sapflow0", "sapflow1", "sapflow2", "sapflow3"].map(label => ({
      //   label,
      //   index: headers.indexOf(label)
      // }));

      // const datasets = [];

      // // Add sapflow datasets
      // sapflowIndices.forEach(({ label, index }, i) => {
      //   const data = dataRows.map(row => ({
      //     x: new Date(row[timestampIndex]),
      //     y: parseFloat(row[index])
      //   })).filter(point => !isNaN(point.y));

      //   datasets.push({
      //     label,
      //     data,
      //     color: colors[i],
      //     // yAxisID: 'y'
      //   });
      // });



      //--------------------draw charts--------------------

         
          drawChart("combinedTempChart", "Temperature (°C)", [
            { label: "Tree Temperature", data: recentData["temperature"], color: "#f97316" },
            { label: "Weather Station Temperature", data: recentWeatherTemp, color: "#3b82f6" }
          ], false);
        
          drawChart("combinedHumChart", "Humidity (%)", [
            { label: "Tree Humidity", data: recentData["humidity"], color: "#ef4444" },
            { label: "Weather Station Humidity", data: recentWeatherHum, color: "#0ea5e9" }
          ], false);
    
          drawChart('pdendrochart', "Point Dendrometer (µm)", [
            { label: "Point Dendrometer", data: recentData["point dendrometer"], color: "#a855f7" }
          ]);

          drawChart('LDchart', "LD", [
            { label: "LD", data: recentData["ld"], color: "#facc15" }
          ]);

          drawChart('batteryChart', "Battery Voltage", [
            { label: "Battery Voltage", data: recentData["battery voltage"], color: "#22c55e" }
          ]);

          const latestBatteryVoltage = parseFloat(sensorData["battery voltage"].slice(-1)[0]?.y || 0);
          drawBatteryChart('batteryPercent', latestBatteryVoltage);

          drawChart('weatherRainfall', "Rainfall (mm)", [
            { label: "Rainfall", data: recentWeatherRainfall, color: "#0ea5e9" }
          ]);

          drawChart('weatherSolar', "Solar Radiation (watts per square meter)", [
            { label: "Solar Radiation", data: recentWeatherSolar, color: "#ffde21" }
          ]);
         

          // drawChart("sapflowchart", "Sap Flow (cm/hr)", datasets, false);

        })
        .catch(err => {
          console.error("Error loading or rendering data:", err);
        });
    </script>


<!-- ================== Carousel Script ================== -->
<script>
  const track = document.querySelector('.carousel-track');
  const slides = Array.from(track.children);
  const nextButton = document.querySelector('.carousel-btn.next');
  const prevButton = document.querySelector('.carousel-btn.prev');
  let currentIndex = 0;

  const getSlidesPerView = () => (
    window.innerWidth <= 480 ? 1 :
    window.innerWidth <= 768 ? 2 :
    window.innerWidth <= 1024 ? 3 : 4
  );

  const updateCarousel = () => {
    const slideWidth = slides[0].getBoundingClientRect().width;
    const slidesPerView = getSlidesPerView();
    const maxIndex = Math.ceil(slides.length / slidesPerView) - 1;
    currentIndex = Math.max(0, Math.min(currentIndex, maxIndex));
    track.style.transform = `translateX(-${slideWidth * slidesPerView * currentIndex}px)`;
  };

  nextButton.addEventListener('click', () => { currentIndex++; updateCarousel(); });
  prevButton.addEventListener('click', () => { currentIndex--; updateCarousel(); });
  window.addEventListener('resize', updateCarousel);
  window.addEventListener('load', updateCarousel);
  
  // Create lightbox element
  const lightbox = document.createElement('div');
  lightbox.classList.add('lightbox');
  document.body.appendChild(lightbox);

  const img = document.createElement('img');
  lightbox.appendChild(img);

  // Click on carousel image to open
  document.querySelectorAll('.carousel-slide img').forEach(image => {
    image.addEventListener('click', () => {
      img.src = image.src;
      lightbox.classList.add('active');
    });
  });

  // Click anywhere to close
  lightbox.addEventListener('click', () => {
    lightbox.classList.remove('active');
  });


</script>

</body>
</html>